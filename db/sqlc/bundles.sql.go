// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: bundles.sql

package db

import (
	"context"
)

const addBundleToCustomer = `-- name: AddBundleToCustomer :exec
INSERT INTO bundles_customers (
  bundles_id, customers_id
) VALUES (
  $1, $2
)
`

type AddBundleToCustomerParams struct {
	BundlesID   int64 `json:"bundles_id"`
	CustomersID int64 `json:"customers_id"`
}

func (q *Queries) AddBundleToCustomer(ctx context.Context, arg AddBundleToCustomerParams) error {
	_, err := q.db.ExecContext(ctx, addBundleToCustomer, arg.BundlesID, arg.CustomersID)
	return err
}

const createBundle = `-- name: CreateBundle :one
INSERT INTO bundles (
  mrc, description
) VALUES (
  $1, $2
)
RETURNING id, mrc, description
`

type CreateBundleParams struct {
	Mrc         float64 `json:"mrc"`
	Description string  `json:"description"`
}

func (q *Queries) CreateBundle(ctx context.Context, arg CreateBundleParams) (Bundle, error) {
	row := q.db.QueryRowContext(ctx, createBundle, arg.Mrc, arg.Description)
	var i Bundle
	err := row.Scan(&i.ID, &i.Mrc, &i.Description)
	return i, err
}

const deleteBundle = `-- name: DeleteBundle :exec
DELETE FROM bundles
WHERE id = $1
`

func (q *Queries) DeleteBundle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBundle, id)
	return err
}

const getBundleByID = `-- name: GetBundleByID :one
SELECT id, mrc, description FROM bundles 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBundleByID(ctx context.Context, id int64) (Bundle, error) {
	row := q.db.QueryRowContext(ctx, getBundleByID, id)
	var i Bundle
	err := row.Scan(&i.ID, &i.Mrc, &i.Description)
	return i, err
}

const listAllBundles = `-- name: ListAllBundles :many
SELECT id, mrc, description FROM bundles
ORDER BY id
`

func (q *Queries) ListAllBundles(ctx context.Context) ([]Bundle, error) {
	rows, err := q.db.QueryContext(ctx, listAllBundles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bundle{}
	for rows.Next() {
		var i Bundle
		if err := rows.Scan(&i.ID, &i.Mrc, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBundlesByCustomerID = `-- name: ListBundlesByCustomerID :many
SELECT bundles.id, bundles.mrc, bundles.description
FROM bundles
JOIN bundles_customers ON bundles.id = bundles_customers.bundles_id
WHERE bundles_customers.customers_id = $1
ORDER BY bundles_customers.customers_id
`

func (q *Queries) ListBundlesByCustomerID(ctx context.Context, customersID int64) ([]Bundle, error) {
	rows, err := q.db.QueryContext(ctx, listBundlesByCustomerID, customersID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bundle{}
	for rows.Next() {
		var i Bundle
		if err := rows.Scan(&i.ID, &i.Mrc, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBundlesWithCustomers = `-- name: ListBundlesWithCustomers :many
SELECT b.id AS bundle_id, b.mrc, b.description, c.id AS customer_id, c.customer
FROM bundles b
JOIN bundles_customers bc ON b.id = bc.bundles_id
JOIN customers c ON c.id = bc.customers_id
ORDER BY b.id, c.id
`

type ListBundlesWithCustomersRow struct {
	BundleID    int64   `json:"bundle_id"`
	Mrc         float64 `json:"mrc"`
	Description string  `json:"description"`
	CustomerID  int64   `json:"customer_id"`
	Customer    string  `json:"customer"`
}

func (q *Queries) ListBundlesWithCustomers(ctx context.Context) ([]ListBundlesWithCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, listBundlesWithCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBundlesWithCustomersRow{}
	for rows.Next() {
		var i ListBundlesWithCustomersRow
		if err := rows.Scan(
			&i.BundleID,
			&i.Mrc,
			&i.Description,
			&i.CustomerID,
			&i.Customer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
